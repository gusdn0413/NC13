package day0513;
// 클래스
// 2세대 언어까지는 프로그램을 기능의 집합으로 보았다.
// 그렇기 때문에 라이브러리 같은 파일들을 만들어서
// 기능을 따로 관리 하고
// 그리고 struct를 만들어서 데이터를 따로 관리하였다.
// 하지만 객체지향적 관점이 시작되면서 "우리가 왜 이것들을 따로 관리해야하지?"
// 라는 관점이 나오게 된다.
// 바로 클래스가 나오게 된 것이다.
// 객체지향 관점에서는 프로그램을 더 작은 프로그램들의 집합으로 보았고
// 하나하나의 작은 프로그램들을 우리가 필요로 할 때 변수로 만들어서
// 사용하게 되는 것이다.

// 클래스는 다음과 같은 항목으로 이루어진다.
// 해당 클래스 변수가 관리할 더 작은 데이터들의 종류(=필드)
// 해당 클래스 변수가 실행 가능한 메소드들

// static
// static 키워드는 해당 클래스의 필드 혹은 메소드를
// 클래스 변수 선언과 초기화 없이 직접 사용을 가능하게 만들어주는 키워드이다.
// 하지만, 해당 방법은 클래스 변수 선언을 하지 않게 하므로
// 객체지향에 반하는 행위이다.
// 따라서 앞으로는, 우리가 static 키워드를 사용하는 것을 최소화하도록 한다.
// 특히 static 메소드는 메인 메소드, ScannerUtil 외에서는 사용하지 않는다.

// 생성자(Constructor)
// 생성자란, 해당 클래스 변수가 초기화 될때 호출되는 메소드로써,
// 처음 해당 클래스 변수에 들어갈 외부의 값이나 아니면 초기화 되는 값
// 또는 특정한 작업을 할 때 호출되는 특수한 메소드이다.
// 만약, 우리가 아무런 생성자를 만들어주지 않는 다면
// 자바에서 기본적으로 제공되는 생성자가 호출이 되는데,
// 해당 생성자는 필드의 값을 기본형 데이터타입의 필드는 0으로
// 참조형 데이터타입의 필드는 null로 초기화해준다.
// 생성자의 경우, 우리가 따로 만들어 줄 수 있는데,
// 한가지 주의할 점은 우리가 파라미터가 있는 생성자만 만들어주면
// 더이상 파라미터가 없는 생성자는 호출할 수 없다.
// 만약 파라미터 있는 생성자와 파라미터 없는 생성자 2개가 모두다 필요하면
// 둘다 만들어주면 된다!

import types.Student;

public class Ex02Class {
    public static void main(String[] args) {
        // Student  클래스 변수 선언 및 초기화
        Student s1 = new Student();
        s1.id = 1;
        s1.name = "김철수";
        s1.korean = 80;
        s1.english = 81;
        s1.math = 81;

        s1.printInfo();

        Student s2 = new Student();
        s2.id = 2;
        s2.name = "이영희";
        s2.korean = 90;
        s2.english = 90;
        s2.math = 91;

        s2.printInfo();

        Student s3 = new Student(10, "김준수", 95, 95, 96);
        s3.printInfo();

        Student s4 = new Student();
        s4.id = 2;
        s4.name = "이영희";
        s4.korean = 90;
        s4.english = 90;
        s4.math = 91;

        System.out.println("s2.equals(s4): " + s2.equals(s4));

    }
}















